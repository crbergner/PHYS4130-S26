# # import important libraries 
# import numpy as np
# import math as m
# import matplotlib.pyplot as plt

# # initialize variables
# x = 2
# df = 
# df_actually = lambda x: (-np.sin(x) * np.tanh(x)) + (np.cos(x) * np.sech(x))

# import libraries
import numpy as np
import matplotlib.pyplot as plt

# initialize variables
x = 2
df = lambda x: (-np.sin(x) * np.tanh(x)) + (np.cos(x) * (1/np.cosh(x))**2)
df_actually = df(x)

h = [10**(-1), 10**(-2), 10**(-3), 10**(-4), 10**(-5), 10**(-6), 10**(-7)]
f_error = np.zeros(len(h))
b_error = np.zeros(len(h))

# define important functions
def forward(f, h):
    return (f(x + h) - f(x)) / h

def backward(f, h):
    return (f(x) - f(x - h)) / h

# loops to fill arrays
for j, hi in enumerate(h):
    fwd = forward(lambda x: np.cos(x) * np.tanh(x), hi)
    bkwd = backward(lambda x: np.cos(x) * np.tanh(x), hi)

    f_error[j] = np.abs(fwd - df_actually)
    b_error[j] = np.abs(bkwd - df_actually)

# plots
m_fwd, _ = np.polyfit(np.log(h), np.log(f_error), 1)
m_bwd, _ = np.polyfit(np.log(h), np.log(b_error), 1)

plt.loglog(h, f_error, label=f'Forward (slope ≈ {m_fwd:.2f})', color = 'red')
plt.xlabel('h')
plt.ylabel('Error')
plt.legend()
plt.show()

plt.loglog(h, b_error, label=f'Backward (slope ≈ {m_bwd:.2f})', color = 'pink')
plt.xlabel('h')
plt.ylabel('Error')
plt.legend()
plt.show()

############################################
# making the h array bigger
h = np.array([10**(-i) for i in range(1, 15)])
f_error = np.zeros(len(h))
b_error = np.zeros(len(h))

# for loop that fills the empty arrays
for j, hi in enumerate(h):
    fwd = forward(lambda x: np.cos(x) * np.tanh(x), hi)
    bkwd = backward(lambda x: np.cos(x) * np.tanh(x), hi)

    f_error[j] = np.abs(fwd - df_actually)
    b_error[j] = np.abs(bkwd - df_actually)

# plots
m_fwd, _ = np.polyfit(np.log(h), np.log(f_error), 1)
m_bwd, _ = np.polyfit(np.log(h), np.log(b_error), 1)

plt.loglog(h, f_error, label=f'Forward (slope ≈ {m_fwd:.2f})', color = 'green')
plt.xlabel('h')
plt.ylabel('Error')
plt.legend()
plt.show()

plt.loglog(h, b_error, label=f'Backward (slope ≈ {m_bwd:.2f})', color = 'blue')
plt.xlabel('h')
plt.ylabel('Error')
plt.legend()
plt.show()

############################################
print("The slope stops being linear when h gets smaller than 10^-7.")
############################################

# intialize variables
h = np.array([10**(-i) for i in range(1, 6)])
c_error = np.zeros(len(h))

# define the central difference function
def central(f, h):
  return (f(x + h) - f(x - h)) / (2 * h)

# for loop that fills the empty arrays
for j, hi in enumerate(h):
    cent = central(lambda x: np.cos(x) * np.tanh(x), hi)
    c_error[j] = np.abs(cent - df_actually)

# plots
m_cent, _ = np.polyfit(np.log(h), np.log(c_error), 1)

plt.loglog(h, c_error, label=f'Central (slope ≈ {m_cent:.2f})', color='purple')
plt.xlabel('h')
plt.ylabel('Error')
plt.legend()
plt.show()
############################################

# intialize variables
h = np.array([10**(-i) for i in range(1, 4)])
fi_error = np.zeros(len(h))

# define the central difference function
def fivept(f, h):
  return (f(x-2*h) - 8*f(x-h) + 8*f(x+h) - f(x+2*h)) / (12*h)

# for loop that fills the empty arrays
for j, hi in enumerate(h):
    five = fivept(lambda x: np.cos(x) * np.tanh(x), hi)
    fi_error[j] = np.abs(five - df_actually)

# plots
m_five, _ = np.polyfit(np.log(h**4), np.log(fi_error), 1)

plt.loglog(h**4, fi_error, label=f'Central (slope ≈ {m_cent:.2f})', color='orange')
plt.xlabel('h^4')
plt.ylabel('Error')
plt.legend()
plt.show()
############################################